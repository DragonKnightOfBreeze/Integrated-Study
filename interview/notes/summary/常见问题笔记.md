# 技术性问题

## 生产者-消费者问题的几种实现方式

* 使用`Object`类的`wait()`和`notifyAll()`方法实现。
* 使用通过`Lock`类的`newCondition()`方法构造的`Condition`类的`await()`和`signalAll()`方法实现，注意需要一个为空条件和一个为满条件。
* 使用`Semaphore`类的`acquire()`和`release()`方法实现，注意需要一个非空信号、一个非满信号和一个互斥信号。
* 使用`BlockingQueue`接口的`put()`和`take()`方法实现。
* 使用`PipedInputStream`和`PipedOutputStream`类实现，通过`connect`将两者连接起来。

## 相等性问题

* 原始类型使用值相等，引用类型使用引用相等。
* 一个引用类型的变量必定不等于另一个实例化出来的引用类型的变量。
* 只要两个变量中存在原始类型的变量，则使用值相等，而非引用相等。
* 字符串有常量池，如果使用字面量表示，则使用常量池中的常量。
* 数字有常量池，其范围是-128~127，如果使用字面量表示，或者使用`valueOf()`表示，或者从原始类型强转类型，则尝试使用常量池中的常量。
* `valueOf()`方法返回对应的包装类型的数字，并尝试使用常量池中的常量，`parseXxx()`方法返回对应的原始类型的数字。

## 排序算法

* **冒泡排序**
  * 属于交换排序
  * 时间复杂度：O(n^2)
  * 基本思路
    * 从前往后依次比较相邻元素的值，如果逆序则交换，使最后两个值有序，循环直到完成排序为止。
    * 如果一趟比较下来没有进行过排序，则说明已经完成排序。
  * 循环：(i=0;i<length;i++) -> (j=i+1,j<length;j++)
* **快速排序**
  * 也叫快速交换排序，属于交换排序，使用到了分治法
  * 时间复杂度：O(n log n)，性能很高
  * 基本思路
    * 从数列中取出一个数作为基准数。
    * 分区过程，将较小或相等的数放到左边，将较大的数放到右边。
    * 递归直到各区间只有一个数为止。
  * 基本思路2
    * i=L;j=R; 将基准数挖出形成第一个坑`a[i]`。
    * j--由后向前找比它小的数，找到后挖出此数填前一个坑`a[i]`中。
    * i++由前向后找比它大的数，找到后也挖出此数填到前一个坑`a[j]`中。
    * 再重复执行2，3二步，直到i==j，将基准数填入`a[i]`中。

## ArrayList的扩容机制

* ArrayList的默认容量为0，最小扩容长度为`所需容量-当前容量`，最大数组长度为`Integer.MAX_VALUE-8`
* 构造ArrayList时，如果指定了初始容量，则为指定值，否则为默认容量。构造时会直接初始化其所维护的数组。
* 当列表长度等于当前容量时，会进行扩容操作。
* 如果新的容量小于等于最大数组长度，则新的容量为旧的容量的1.5倍，使用到了无符号右位移运算符；
  否则，若最小扩容长度小于等于最大数组长度，则扩容到最大数组长度，否则扩容到`Integer.MAX_VALUE`。
  
## HashMap的扩容机制

# 沟通性问题

## 个人介绍

面试官你好，我叫施诚，是一名2020届九江学院计算机科学与技术专业的应届生，来安徽池州。我性格沉稳、随和而乐观，热爱思考问题和钻研问题。我对编程抱有浓厚的兴趣，拥有良好的自主学习能力和整理归纳能力，愿意花费时间和精力在编程学习和项目开发上，并且乐于接受和学习新技术、新知识。我熟悉java、kotlin和前端技术，能够熟练使用spring boot、spring data jpa、mybatis、vue等主流开源框架，曾经开发过相关练习项目和工具类库。以上就是我的自我介绍。

## 项目开发中遇到的问题

可以从毕业设计项目的开发流程说起：
java→lombok→lombok++→kotlin→allopen和noarg→jpa级联→{pageable}→@DateFormat→@Primary→并发的必要性

* 需要特别关注的基础问题：字符串的几种比较方式
* 需要特别关注的基础问题：`Arrays.asList()`和`List.of()`方法返回的列表的只读性
* 并发的必要性：不需要等待执行完毕的操作，有必要使用线程或协程处理
* 隐蔽的代理模式：allopen和noarg编译插件的必要性：spring和jpa低层的cglib动态代理
* 无参构造参数可能的必要性：对于jackson反序列化、jpa实体类和springboot属性类
* 深入学习和导师的必要性：特殊注解如`@Primary`在特殊情况下的必要性
* 前端页面元素的排序方式：最好统一使用流式布局，因为第三方提供的排序方式可能不完善。
* Vue响应式的问题：监听器不会监听数组或对象内部的变化
* 传参：前端传递Pageable参数时的几个属性
* 实践：`findByFooList`在jpa中是合法的
* 传参：jackson必须通过`@DateFormat`格式化时间到前端
* junit4和junit5：后者可以构造器自动装配，可以非public的类和方法
* jpa级联：没有想象中的那么好，情况太复杂

## 向面试官的提问

* 下一步的招聘流程是怎样的？
* 贵公司对新入公司的员工有没有什么培训项目？
* 贵公司的项目中都使用到了哪些技术？
* 贵公司有什么技术挑战？

