synchronized（加锁），锁定的是对象，当在synchronized里写一方法时，锁定的是this当前对象，如果这个方法是static的，则锁定的是class对象（类加载时期的那个class对象）


1、用多线程的目的是什么？
	充分利用CPU资源，并发做多件事

2、单核CPU机器上适不适合用多线程？
	适合，如果是单线程，线程中需要等待IO时，此时CPU就空闲出来了（这个适合也不是绝对意义上的适合，因为要去考虑线程切换的成本问题）

3、线程什么时候回让出CPU？
	线程阻塞时   wait await 等待IO
	Sleep时
	yield
	结束了

4、线程是什么？
	一条代码执行流，完成一组代码的执行
	这一组代码，我们往往称为一个任务

5、CPU做的是什么？
	执行代码（计算）

所以，总结来说，就是当我们有一个任务时，把这个任务装到线程里面，这个线程是一个程序或者任务的运送单位，它的目标就是把我们的这个任务运送到CPU里面去执行对应代码进行处理计算    这就是整个任务或者一个线程整体要干的事

6、线程是不是越多越好？
	假如有大量的任务，CPU有四个，那么就会去开辟一块内存，之后再内存中去创建我们的线程，大量任务创建大量线程，那么线程就会非常的多，之后由线程将任务送到CPU中，但是并不是创建的线程越多越好，因为内存可能支撑不住   -Xmx200m(说明在jvm里开辟出一个200M的堆内存)
	1、new一个线程是需要时间的，一次性使用，用完了得销毁，销毁需要时间，线程在java中是一个对象，每一个java线程都需要一个操作系统线程支持。线程创建、销毁需要时间。如果   创建时间+销毁时间 > 执行任务时间，那么就很不划算了，所以并不是线程越多越好；
	2、另外java对象占用的是堆内存，操作系统线程占用系统内存，根据jvm规范，一个线程默认最大栈大小是1M，这个栈空间是需要从系统内存中分配的，线程过多的话，就会去消耗掉很多的内存
	3、创建很多线程的话，需要空间来释放他们，会造成内存紧张。因为，操作系统需要频繁切换上下文（大家都想被运行），就会影响性能

7、该如何正确地使用多线程？
	多线程目的：充分利用CPU并发做事（多做事）
	线程本质：将代码运送给CPU
	用合适数量的线程不断运送代码即可
	这合适的数量就构成了一个池
	有任务要执行，就放入池中，池中的一个线程将把任务运送到CPU执行

线程池中有线程和任务仓库（任务先放到任务仓库中，任务仓库有个功能相当于Springcloud中的hystrix（熔断器，限流，比如只接受处理200个请求就不在接受了），那么任务仓库完成限流的功能是当把任务一直放到仓库中，仓库被放满了的话，就不在允许任务的提交了）   线程池里的工作线程就把对应的任务送到CPU中执行    如果仓库中没有任务了，那么线程池里的那些线程就会造成阻塞

	1、任务可以Runnable和Callable标识，Runnable就

	2、线程池的任务仓库就是一个BlockingQueue（阻塞队列，线程安全的），会在队列为空时获取阻塞，在队列满的时候放入阻塞
	   BlockingQueue方法以四种形式出现，对于不能立即满足但可能在将来某一时刻可以满足的操作，这四中形式的处理方式不同：第一种是跑出异常，第二种是返回一个特殊值（null或false，具体取决于操作），第三种是在操作可以成功前，无限期的阻塞当前队列，第四种是在放弃前只给定最大时间限制内阻塞。
	   插入有抛出异常的add(e)，返回特殊值的offer(e),阻塞的put(e)，超时的offer(e,time,unit)
	   移除有抛出异常的remove(),返回特殊值的poll().阻塞的take(),超时的poll(time,unit)
	   检查有抛出异常的element(),返回特殊值的peek()

	ExecutorService加入关闭方法和对Callable、Future的支持，比如他的shutdown()关闭当前线程（已提交的任务会执行完成），shutdownNow()正在执行的任务执行完成，未执行的任务不执行了，submit()提交任务，invokeAll()执行集合中所有任务，invokeAny()集合中一个任务被执行完，其他则不再执行
	ScheduleExecutorService加入对定时任务的支持，比如他的schedule()多久后执行，scheduleAtFixedRate()周期性执行（以固定的时间频率重复执行任务，如每5分钟，但是当任务本身耗时超过时间频率，下次执行需等待该次执行完成后才能开启，不能并发执行），scheduleWithFixedDelay()周期性执行（以固定的任务间延迟来重复执行任务，下一次执行是在上一次执行完后间隔时间在执行，也就是中间有个延迟等待时间）
	Callable：对Runnable的改进，可以返回值，可以抛出异常
	Future：异步任务监视器，让提交者可以监听任务的执行，超时机制便可以通过Future的get()方法去做
	ThreadPoolExecutor：线程池标准实现
		public ThreadPoolExecutor (int corePoolSize(核心线程数),int maximumPoolSize(最大线程数),long keepAliveTime(非核心线程的存活时间),TimeUnit unit,BlockingQueue<Runnable>workQueue(仓库))	核心线程只有在极端情况下才会被回收，比如当前线程池已经没有资源了		非核心线程的创建时间要满足两个条件：1、核心线程数已经满了；2、queue（仓库）也满了		所以，如果有一个无界队列（或者仓库是一个无界队列）（没有上限），线程池中最大线程数为400，核心线程数为100，这时有10000个任务需要调用线程，那么只会有100个线程再跑，因为queue（仓库）没满，所以其他300个非核心线程是还没有创建的
	Executors创建线程池的工厂类，减轻我们的任务，他的工厂方法：
		newFixedThreadPool(int nThreads)创建一个固定大小、任务队列容量无界的线程池。池的核心线程数=最大线程数=nThreads。   这个方法的问题有：1、队列的线程多了导致反应变慢、2、线程实在太多可能会丢数据；3、死机（可能性不是很大）
		newCachedThreadPool()创建的是一个大小无界的缓冲线程池。他的任务队列是一个同步队列。任务加入到池中，如果池中有空间线程，则用空闲线程，如无空闲线程则创建新线程执行。池中的线程空闲时间超过60秒，将被销毁释放。池中的线程随任务的多少变化。缓冲线程池适用于执行耗时较小的异步任务。     池的核心线程数=0    最大线程数=Integer.MAX_VALUE（相当于当前线程池的容量是无限的，如果在高并发的场景下，比如1秒钟能接到5万个请求，那么1秒钟就会出来5万个线程，如果是一个IO的线程，每一个执行假如是2秒那么这时就会发现机器的内存在疯狂的增长，最后导致死机）
		newSingleThreadExecutor()只有一个线程来执行无界任务队列的单一线程池。该线程池确保任务按加入顺序一个一个依次执行，任何时刻只有一个任务在执行。当唯一的线程因任务异常终止时，将创建一个新的线程来继续执行后续的任务。单一线程池与newFixedThreadPool(1)的区别在于，单一线程池的池大小是不能再改变的
		newScheduleThreadPool(int corePoolSize)能定时执行任务的线程池。该池的核心线程数由参数指定  最大线程数=Integer.MAX_VALUE

被多个线程访问的资源就是临界资源


线程的状态：
	1、新生态（new）：一个线程对象被实例化完成
	2、就绪态（Ready）：一个线程已被开启，开始争抢CPU时间片
	3、运行态（Run）：一个线程抢到了CPU时间片，开始执行这个线程中的逻辑
	4、阻塞态（Interrupt）：一个线程在运行的过程中，受到某些操作的影响，放弃了已经获取到的CPU时间片（yield线程礼让），并且不再参与CPU时间片的争抢，此时线程处于挂起状态
	5、死亡态（Dead）

运行态到阻塞态：1、在控制台输入（Scanner），此时程序是处于一个暂停状态的；2、sleep；3、join
阻塞态回到运行态：1、用户输入完成        2、等待休眠时间结束         3、等待合并进来的线程结束

运行态调用wait方法也会进入阻塞态，此时叫做等待队列，由等待队列可以进入锁池的，用notify或者notifyAll，锁池回到就绪态需要获得线程锁标记
运行态也可以直接进入锁池，需要等待锁标记